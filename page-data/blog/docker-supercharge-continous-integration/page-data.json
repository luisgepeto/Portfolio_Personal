{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/docker-supercharge-continous-integration","result":{"data":{"markdownRemark":{"html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABJ0AAASdAHeZh94AAABxklEQVQoz12RT2sTURTF5xPo1k1BUHHvyoUfwE03pSAIushScKuuXIjipqVFC+pCV0qRWqPUURMbKUzaKTXYsQlkklhJUmqmkyZpEtNJ59/PmTdTrV5475377n3nnvuu5Ps+XrBCa3X7zKQUKg1T+PiuOFzPi/0ob3/9C1ZhXWCruMEgp0Zhz0Xy4yRFy3Ph3iNO3pxgdknF6PS4rZQwgiKh7bZa2MOhwN0Ht2jfuYaza9K5e53u9I24fkAYgsV8mTOT84xMvubsVJJzD98wPqcy9jzDptHEORiSSCSQZTlSnBzDunqM2vlT7F85jjc/ipAVbIIwrRU5PSMz8iSDNL2IdF/m4tMUg3YT4naz2Sw7hiGw9+s79uxlWqMnsF9cwuuXBWHYrURstXqdZ6t5xl8u83i5EJX7b+cf7OBqbwO51t9IqLC9t0fyY5rsWg69qLNZ0lFXVsh9y6MEd4bZjJ670YAawRfUaluUKlXM3gG9/gC9VKHd6Yq4VN3aZiGdIbWksPDpM+pXjVfvU8y9+yDurHgQXtx6wzADsh9sFHSq1TrlAK+uaWz/3IkID5MPp23bTizfP9KK/8cPTzdWazuOWEff/wY5CDq0EapQGwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/b509ffce673c9084f398a745a190a42a/ba381/docker-gitlab-logo.webp 200w,\n/static/b509ffce673c9084f398a745a190a42a/7f61c/docker-gitlab-logo.webp 400w,\n/static/b509ffce673c9084f398a745a190a42a/d00b9/docker-gitlab-logo.webp 800w,\n/static/b509ffce673c9084f398a745a190a42a/92f8c/docker-gitlab-logo.webp 1200w,\n/static/b509ffce673c9084f398a745a190a42a/c6231/docker-gitlab-logo.webp 1572w\"\n              sizes=\"(max-width: 800px) 100vw, 800px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/b509ffce673c9084f398a745a190a42a/772e8/docker-gitlab-logo.png 200w,\n/static/b509ffce673c9084f398a745a190a42a/e17e5/docker-gitlab-logo.png 400w,\n/static/b509ffce673c9084f398a745a190a42a/5a190/docker-gitlab-logo.png 800w,\n/static/b509ffce673c9084f398a745a190a42a/c1b63/docker-gitlab-logo.png 1200w,\n/static/b509ffce673c9084f398a745a190a42a/5df5d/docker-gitlab-logo.png 1572w\"\n            sizes=\"(max-width: 800px) 100vw, 800px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/b509ffce673c9084f398a745a190a42a/5a190/docker-gitlab-logo.png\"\n            alt=\"Docker and GitLab logos\"\n            title=\"Docker and GitLab logos\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n    </span></p>\n<p>Whenever we hear that a project uses Docker, automatically the microservices architecture comes into mind. However Docker is not only useful among the microservices paradigm. Many of the leading Git platforms rely on Docker images for their CI (Continous Integration) pipelines. Over this post we will focus on GitLab (although other providers such as GitHub or Bitbucket follow similar concepts) to explain how Docker can help us to supercharge our CI, including the creation of custom images to include even the most complex project requirement.</p>\n<h1>The basics</h1>\n<h2>GitLab pipelines 101</h2>\n<p>The easiest way to understand pipelines in GitLab is to imagine a series of orderly applied transformations that are performed against a clean copy of your repository. Each of these steps is called a <em>stage</em>. Each stage can contain multiple operations which usually occur in parallel. These operations are called <em>jobs</em>. The <em>stages</em> are then defined inside a custom <code class=\"language-text\">gitlab-ci.yml</code> file which lives at the root of your repository. Here is a sample file with basic configuration:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-yml line-numbers\"><code class=\"language-yml\"><span class=\"token key atrule\">default</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mcr.microsoft.com/dotnet/core/sdk<span class=\"token punctuation\">:</span>latest\n\n<span class=\"token key atrule\">stages</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> build<span class=\"token punctuation\">-</span>stage\n  <span class=\"token punctuation\">-</span> test<span class=\"token punctuation\">-</span>stage\n\n<span class=\"token key atrule\">build-job</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">stage</span><span class=\"token punctuation\">:</span> build<span class=\"token punctuation\">-</span>stage\n  <span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> dotnet build\n    \n<span class=\"token key atrule\">test-job</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">stage</span><span class=\"token punctuation\">:</span> test<span class=\"token punctuation\">-</span>stage\n  <span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> dotnet test</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Of course there are a lot of ways that we can customize <em>jobs</em> and <em>stages</em> such as conditional execution or artifact creation, however this will be the topic for another post. </p>\n<h2>Docker + GitLab</h2>\n<p>Now, you may wonder, where does Docker come into play? Well, every time that a new <em>job</em> is started and a fresh copy of the repository is created, it is started inside a running container of a base Docker image defined in your <code class=\"language-text\">gitlab-ci.yml</code>. Did you see the first <code class=\"language-text\">image:</code> declaration in the <code class=\"language-text\">.yml</code> file? Well that will be our default Docker image that will be used to start each of our jobs. That is the reason why inside our <code class=\"language-text\">script</code> component we can use the <code class=\"language-text\">dotnet</code> CLI. </p>\n<h1>Start supercharging your CI</h1>\n<h2>Use different Docker images between jobs</h2>\n<p>Let's say that your project consists in a backend written in .NET, while you have a SPA written in React, and that both projects are inside the same repository. You will need to compile both as part of your CI pipeline, however one depends in the <code class=\"language-text\">dotnet</code> CLI, while for the other you need <code class=\"language-text\">npm</code>. This might not be very easy if the same <code class=\"language-text\">mcr.microsoft.com/dotnet/core/sdk:latest</code> image is used for both scenarios. Therefore you can define separate <em>jobs</em> based on different images:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-yml line-numbers\"><code class=\"language-yml\"><span class=\"token key atrule\">stages</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> build<span class=\"token punctuation\">-</span>stage \n\n<span class=\"token key atrule\">build-backend</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">stage</span><span class=\"token punctuation\">:</span> build<span class=\"token punctuation\">-</span>stage\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mcr.microsoft.com/dotnet/core/sdk<span class=\"token punctuation\">:</span>latest  <span class=\"token comment\"># we can define an image per job</span>\n  <span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> dotnet build\n    \n<span class=\"token key atrule\">build-frontend</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">stage</span><span class=\"token punctuation\">:</span> build<span class=\"token punctuation\">-</span>frontend\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> node<span class=\"token punctuation\">:</span>12.6.0<span class=\"token punctuation\">-</span>alpine <span class=\"token comment\"># we can define an image per job</span>\n  <span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> npm run build</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>Create your own Docker image with custom tools</h2>\n<p>Now, lets say that you want to extend your CI pipeline functionality to <a href=\"https://slack.com/intl/en-mx/help/articles/202009646-Notify-a-channel-or-workspace\">notify a Slack channel</a> whenever the backend build is finished. For this, you could create a sample <code class=\"language-text\">slack-notification.js</code> file that uses the Slack webhook API and that will be run with node. We won't go over the details for this here, but suppose your file calls:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> slack <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'slack-notify'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token constant\">SLACK_WEBHOOK_URL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nslack<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> channel<span class=\"token operator\">:</span> <span class=\"token string\">'#my-channel'</span><span class=\"token punctuation\">,</span> text<span class=\"token operator\">:</span> <span class=\"token string\">'Notifying from CI!'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>However, we cannot call this after the <code class=\"language-text\">dotnet build</code> script, since the <code class=\"language-text\">mcr.microsoft.com/dotnet/core/sdk:latest</code> image does not include the node dependencies. Therefore, we would need to create a custom image, upload it to some container registry (such as <a href=\"https://azure.microsoft.com/en-us/services/container-registry/\">Azure Container Registry</a>, or even GitLab) and use it as our base image. </p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-dockerfile line-numbers\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> mcr.microsoft.com/dotnet/core/sdk<span class=\"token punctuation\">:</span>latest\n<span class=\"token keyword\">RUN</span> curl <span class=\"token punctuation\">-</span>sL https<span class=\"token punctuation\">:</span>//deb.nodesource.com/setup_14.x <span class=\"token punctuation\">|</span> bash &amp;&amp; \\ <span class=\"token comment\"># we install the node dependencies</span>\n    apt<span class=\"token punctuation\">-</span>get install <span class=\"token punctuation\">-</span>y nodejs</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Then inside our <code class=\"language-text\">build-backend</code> job we could add the following to the scripts array:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-yml line-numbers\"><code class=\"language-yml\"><span class=\"token key atrule\">build-backend</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">stage</span><span class=\"token punctuation\">:</span> build<span class=\"token punctuation\">-</span>stage\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> my<span class=\"token punctuation\">-</span>custom<span class=\"token punctuation\">-</span>image<span class=\"token punctuation\">-</span>with<span class=\"token punctuation\">-</span>net<span class=\"token punctuation\">-</span>and<span class=\"token punctuation\">-</span>node  <span class=\"token comment\"># we can define an image per job</span>\n  <span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> dotnet build\n    <span class=\"token punctuation\">-</span> node slack<span class=\"token punctuation\">-</span>notify.js</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>Create a Docker image inside a pipeline! 🤯</h2>\n<p>Last but not least, it is also possible to use create a Docker image from the latest compiled code in the repository. This is useful in case another team is working in a project that depends on ours. This way, whenever they want to run our project without the need to set up their local environments and download any other dependencies, they can just pull the Docker image generated from the latest code in our repo. For that we can use <a href=\"https://docs.gitlab.com/ee/ci/docker/using_docker_build.html\">Docker-in-Docker</a> </p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-yml line-numbers\"><code class=\"language-yml\"><span class=\"token key atrule\">deploy_app:docker</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">stage</span><span class=\"token punctuation\">:</span> deploy\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> docker<span class=\"token punctuation\">:</span>dind    \n  <span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> docker login <span class=\"token punctuation\">-</span>u $CI_REGISTRY_USER <span class=\"token punctuation\">-</span>p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    <span class=\"token punctuation\">-</span> docker build <span class=\"token punctuation\">-</span>t $CI_REGISTRY_IMAGE<span class=\"token punctuation\">:</span>latest .\n    <span class=\"token punctuation\">-</span> docker push $CI_REGISTRY_IMAGE<span class=\"token punctuation\">:</span>latest</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>Final thoughts</h1>\n<p>Docker is a very powerful tool, both as a vital enabler for microservices, but also to supercharge our CI pipelines. The possibilities of Docker are almost endless since we can use it in very creative ways to build tools that accomodate to our specific project and organizational needs. If you wish to start learning <a href=\"https://www.docker.com/\">Docker</a> I recommend you take a look at their webpage. Also if you wish to know more regarding pipelines, I suggest you refer to the <a href=\"https://docs.gitlab.com/ee/ci/pipelines/index.html\">GitLab CI pipeline documentation</a></p>","excerpt":"Whenever we hear that a project uses Docker, automatically the microservices architecture comes into mind. However Docker is not only useful among the…","frontmatter":{"date":"02 June, 2021","path":"/blog/docker-supercharge-continous-integration","title":"Docker: supercharge your CI pipeline"},"fields":{"readingTime":{"text":"5 min read"}}}},"pageContext":{}},"staticQueryHashes":["3000541721","3649515864"]}